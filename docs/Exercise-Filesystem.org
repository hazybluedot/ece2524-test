#+TITLE: The Filesystem - Exercises
#+LaTeX_HEADER: \usepackage{framed}
#+LaTeX_HEADER: \usepackage{xcolor}
#+LaTeX_HEADER: \definecolor{shadecolor}{gray}{.95}
#+LaTeX_HEADER: \newenvironment{example}{\begin{shaded}}{\end{shaded}}
#+LaTeX_HEADER: \newenvironment{sidebar}{\begin{shaded}}{\end{shaded}}


* Introduction
* Unix directories

It is time to do some work with directories in Unix. If you haven't
already done so, boot GNU/Linux and open a shell window. In the
discussion below, once again I'll follow the convention that I
introduced last week: =the things styled like this= are what you type,
and everything shown =like this= is generated by the computer. I'll
assume that the shell's prompt is %. Remember that you need to press
ENTER after each command that you type.

First, determine your present working directory in the new shell window
with the command =pwd=. You should see something similar to the
following:

#+BEGIN_EXAMPLE
$ pwd
/home/jane
$
#+END_EXAMPLE

The response, =/home/jane=, agrees with what we would expect for a user
with a login name (UID) of =jane=.

If we want to change to a different directory, the format of the command
is =cd new-directory-name=. One good thing about Unix is that you are
allowed (and encouraged) to explore the file system. You can visit the
root directory, for example, as follows:

#+BEGIN_EXAMPLE
$ cd /
$ ls
bin     etc             lib         mnt   . . .
boot    home            lib64       opt   . . .
cdrom   initrd.img      lost+found  proc  . . .
dev     initrd.img.old  media       root  . . .
$ pwd
/
$
#+END_EXAMPLE

The root directory will continue to be your current directory until you
use =cd= again (or a command that is closely related to =cd=). With =ls=
we get a listing of several system-level files and directories. It is
possible that your listing is a bit different from the output shown
above; it is common to see some differences here from one semester to
the next.

If you provide a directory as a command-line argument to =ls=, it will
list the contents of that directory. You can specify the directory with
an absolute path name or a relative path name. Try it with =ls /bin=:

#+BEGIN_EXAMPLE
$ ls /bin
arch     bzcat         chmod  date       dmesg          ed       . . .
awk      bzip2         chown  dd         dnsdomainname  egrep    . . .
bash     bzip2recover  cp     df         domainname     false    . . .
bashbug  cat           cut    dir        du             fgrep    . . . 
bunzip2  chgrp         dash   dircolors  echo           findmnt  . . .
$
#+END_EXAMPLE

You should see a listing of perhaps 100 files. Some of those files
should have familiar names, because this is where Unix keeps the
executable files for some common shell commands. You might also spot
=cat=, for example, and even =bash=. Most Unix shell commands are simply
the executable (compiled) versions of programs that sit in files,
somewhere in the file system. Please note that different versions of
Unix may keep shell commands in different locations.

You can get the same listing by going into that directory and typing ls
without any arguments:

#+BEGIN_EXAMPLE
$ cd /bin
$ ls
... (same as above)
$
#+END_EXAMPLE

#+BEGIN_SIDEBAR
Mini-exercise and review: How can you use =ls= along with metacharacters
(wildcards) to list all file names that begin with the letter "c" in the
=/bin= directory? How can you list all files that contain a hyphen in
the file name? What command will list all files with 2-character names?
#+END_SIDEBAR

To return to your home directory, you can type =cd= with no arguments.
Then you can create a new directory for yourself using =mkdir=. Do that
using the name =week3=, and go into this new directory:

#+BEGIN_EXAMPLE
$ cd
$ mkdir week3
$ ls
Desktop week3
$ cd week3
$ pwd
/home/jane/week3
$ ls
$ ls -a
. ..
$
#+END_EXAMPLE

As you might expect, a newly created directory is empty. With =ls =, you
see that the only hidden files in this new directory are =.= and =..=,
which represent the current and parent directories, respectively. These
symbols appear in every Unix directory, even "empty" ones. Now create a
subdirectory within this new subdirectory:

#+BEGIN_EXAMPLE
$ pwd
/home/jane/week3
$ mkdir newdir
$ ls
newdir
$ echo Hello > newfile
$ ls
newdir newfile
$ ls -F
newdir/ newfile
$ ls -l
drwxr-xr-x 2 ubuntu ubuntu 40 Sep 8 17:03 newdir
-rw-r--r-- 1 ubuntu ubuntu 6 Sep 8 17:03 newfile
$
#+END_EXAMPLE

If the =-F= switch for =ls= has not been introduced yet in this course,
here it is. This option causes =ls= to append some characters to some
names in the listing. The most common characters are / to indicate
directories, and * to indicate executable files. Those extra characters
are not part of the file names; they are just printed by ls as a visual
aid for quickly identifying different types of files and directories.
This capability is nice when there is no color-coding of the
file/directory names.

#+BEGIN_SIDEBAR
Mini-exercise and review: Try to predict what you'll see (before typing
it) the =ls= command with different combinations of the switches =-a=,
=-F=, and =-l=. For example, what will you see with =ls -a -F= and with
=ls -aFl=? Verify your predictions.
#+END_SIDEBAR

The command to remove a directory is =rmdir=. We could use it now to get
rid of =newdir=, but first see what happens if =newdir= is not empty.

#+BEGIN_EXAMPLE
$ mv newfile newdir
$ ls newdir
$ ls newdir newfile
$ rmdir newdir
rmdir: failed to remove 'newdir': Directory not empty
$
#+END_EXAMPLE

So you see, Unix does provide a bit of built-in protection against
removing directories inadvertently. Normally, you should empty a
directory before getting rid of it. Here is one way to accomplish that:

#+BEGIN_EXAMPLE
$ rm newdir/*
$ rmdir newdir
$ ls
$
#+END_EXAMPLE

The =rm= command above says to remove all files from directory =newdir=.
We have to be very careful with =rm=, expecially when using the
metacharacter =*=. If we accidentally put space characters in front the *
in this example, and if any regular files were present in the current
directory, then all of those files would be erased. Remember that there
is no "recycle bin" when you work with the Unix shell. A seasoned Unix
user will always hesitate and double-check any command that involves
both =rm= and =*=.

There is another way to remove directories: with the command =rm -r=. The
=-r= switch stands for recursive. In addition to removing files, this
command will remove directories even if they are not empty. Yes, if you
type =rm  directory-name=, then that directory and all files and all
subdirectories below it are removed. So if you ever use =rm =, be very
careful with it.

#+BEGIN_SIDEBAR
The GNU version of =rm= allows options to come after the file name.
When I want to completely delete a directory I will use

: rm directory-name -r

By waiting until the end of the command to type =-r= I reduce the
chances of accidently hitting ENTER before finishing typing the full
path.
#+END_SIDEBAR

* Changing file permissions

It is time to create a simple shell script. As described earlier, a
shell script is nothing more than a text file that contains a sequence
of valid Unix shell commands. (This is true regardless of the file
permission settings, which we'll explore below.) Start by placing the
two commands =date= and =pwd= inside a file named mydate. I assume that
you are still in the new (but now empty) =week3= directory:

#+BEGIN_EXAMPLE
$ pwd
/home/jane/week3
$ ls
$ echo date > mydate
$ echo pwd >> mydate
$ cat mydate
date
pwd
$ ls -l
-rw-r--r-- 1 jane jane
9 Sep 8 17:10 mydate
#+END_EXAMPLE

Recall that the special character > causes the shell to redirect output
from a command into a file, instead of sending it to the screen. If the
file already exists, its contents are overwritten by default. (Again:
caution!) The >> characters also cause redirection into a file, but this
time without erasing anything. The new characters are appended to the
end of the file.

So now we have created an ASCII text file called =mydate=, and it
contains some shell commands. We can execute those commands in several
ways:

#+BEGIN_EXAMPLE
$ source mydate
Tue Sep 8 17:11:43 UTC 2009
/home/ubuntu/week3
$ bash mydate
Tue Sep 8 17:12:13 UTC 2009
/home/ubuntu/week3
#+END_EXAMPLE

The command source causes the shell to execute the commands contained in
the file. You can see that the shell has executed the two commands date
and pwd in the order that they appear in =mydate=. It is even possible
to run =bash= in "batch" mode (non-interactively) as you see here. It
works with most other Unix shells as well. Try it with =sh=, for
example.

Usually when we create a shell script, however, we would prefer to just
type the name of the file by itself, =mydate= in this case. Let's try
that now:

#+BEGIN_EXAMPLE
$ mydate
bash: mydate: command not found
#+END_EXAMPLE

Well, that didn't work so well. Whenever a command is "not found," it
means that the shell did not know where to find it, even though the
actual file may be sitting in the current directory. The shell decides
where to find commands by consulting something called a PATH variable.
Let's defer that discussion until the next section.

If the shell does not know where to find the file that we created, we
can explicitly specify the file's location by giving a full path name,
or a relative path name as shown here:

#+BEGIN_EXAMPLE
$ ./mydate
bash: ./mydate: Permission denied
#+END_EXAMPLE

So this time bash has found the mydate file and has attempted to execute
it, but does not have permission to do so. To fix this problem, we need
to use the =chmod= command:

#+BEGIN_EXAMPLE
$ chmod +x mydate
$ ./mydate
Tue Sep 8 17:16:45 UTC 2009
/home/ubuntu/week3      
#+END_EXAMPLE

The =chmod +x= command, as shown above, has turned on the execute
permissions for the file =mydate=. Then when the user tries to execute
the file, the shell first checks these permission settings. The shell
will not execute the command unless the permission settings allow it. We
can look at those settings by using the following command:

#+BEGIN_EXAMPLE
$ ls -l
-rwxr-xr-x 1 jane jane 9 Jan 28 17:10 mydate       
#+END_EXAMPLE

Note the =x= characters in the output, which were not there when we ran
=ls -l= before. These permissions tell us that the owner of the file can
read/write/execute the file, whereas everyone else on the Unix system
can read and execute it but not write (change or remove) it. If you now
run =ls -F=, you will see the character =*= appended to the file name,
indicating that the file is executable.

If you recall the octal coding scheme that was introduced in this week's
lecture, then you know that we could have obtained the same permission
settings with the command

#+BEGIN_EXAMPLE
$ chmod 755 mydate    
#+END_EXAMPLE

If you do not remember this numerical method, then now is a good time to
stop and review that.

Mini-exercise: Use the numerical (octal) scheme to turn off all of the
permissions for file mydate. Then =ls -l= should report =---------=.
Because you no longer have "write" permission for the file, even though
you are its owner, you should not be able to delete the file in the
usual way. Try that to see what happens.

* Shell variables

Every Unix shell maintains several "variables" that can be used to
customize your sessions. You were introduced to one of them already:
bash uses a shell variable with the unlikely name PS1 to specify the
prompt that you see, such as =$=, during an interactive shell session.
Last week you saw how to set the prompt by giving PS1 a new value.

Perhaps the most important shell variable is named PATH (all
upper-case), because the shell uses it to find commands to
execute. The format is =dirname1:dirname2:dirname3:...= , where each
dirname specifies a directory for the shell to search. Each
directory's name is separated by a colon (:). Whenever you enter a
command, the shell searches those directories in the order that they
appear in the PATH variable for a file matching the command name that
you typed.

You can see the current value of the PATH variable by typing =echo
$PATH=. (The $ character tells the shell not to echo the string
"=PATH=", but instead to treat PATH as a variable and to get its
value.)  Try typing that now. You should see a long string that may
begin with =/usr/local/sbin:/usr/local/bin: ...=. In the previous
section, we typed the command name =mydate=, and the shell searched
all of the directories specified in PATH for a file named
=mydate=. When the search turned up empty, the shell reported =command
not found=.

The solution is to add a period to the PATH, because "=.=" always refers
to the current directory. You can do this with the following command:

#+BEGIN_EXAMPLE
$ PATH=$PATH:.
#+END_EXAMPLE

Now if you type =echo $PATH= you should see ``=.='' given as the last
directory. Then if you type =mydate= it should work as if it were a
standard shell command.

#+BEGIN_SIDEBAR
A thought experiment: The "=.=" is probably omitted from the PATH variable
on the Ubuntu distribution because this practice is a potential security
risk. Suppose someone wants to trick you into running a malevolent
program. Can you think of a way to exploit the versatility of the shell,
especially if "=.=" is somewhere in the PATH variable?

But in spite of the possible security risk, many Unix users use PATH in
this way. I don't think it will be a problem for us in this course, so
long as everyone is aware of possible misuse.
#+END_SIDEBAR

* File links

Recall that Unix symbolic links are very much like "shortcuts" on
Microsoft systems. When using the Unix shell, a symbolic link gives us
another name to refer to a file. But if that file is moved or deleted,
then the symbolic link is no longer useful.

#+BEGIN_SIDEBAR
Mini-exercise: Run these commands in order and observe the results:

#+BEGIN_EXAMPLE
chmod 755 mydate
ln -s mydate mylink
ls -l
ls -F
#+END_EXAMPLE

Notice the special symbols when =-l= is used. What special character
appears when =-F= is used?

#+BEGIN_EXAMPLE
cat mylink
mv mydate mydate2
cat mylink
rm mylink
#+END_EXAMPLE

This should demonstrate that a symbolic link is associated with a
particular file name, not the contents of that file.
#+END_SIDEBAR

Now use =ls -l= or =-F= to look at the contents of the root directory
again. Is it possible to create symbolic links to directories? Perhaps
things are not as simple as they appeared before.

A Unix hard link is associated with the actual contents of a file. It
is sometimes called a direct pointer to the file. In fact, the common
file names themselves are sometimes referred to as hard links. We can
create any number of hard links to a file, so long as they are on the
same physical disk partition. (Symbolic links are not limited in this
way; they can operate across different disk partitions.) If the name
of one of those links changes, or if one of those links is removed,
then the other hard links are not affected. The file is truly removed
only when the last hard link is removed.

#+BEGIN_SIDEBAR
Mini-exercise: Run these commands in order and observe the results. I am
continuing from the running example above, and I assume that file
mydate2 currently exists.

#+BEGIN_EXAMPLE
ln mydate2 mydate3
ls -l
ls -F
#+END_EXAMPLE

When =-l= is used, one of the columns indicates the number of hard
links. What is that number for these two cases. What do you notice when
=-F= is used?

#+BEGIN_EXAMPLE
cat mydate2
cat mydate3
rm mydate2
cat mydate3
#+END_EXAMPLE

This should demonstrate that a hard link does not depend on any other
hard links to the same file.
#+END_SIDEBAR

* Disk status

The =df= and =du= commands can provide information concerning the amount
of disk space that is being used on your system. First run df, which
stands for "disk free." At the left you should ideally see references to
physical part of your computer, and on the right you should see
associations with the logical file system. For example, on one of my
machines the =df= command reports that device =/dev/sda1=, which is my
CD drive, is associated with (has been ``mounted'' on) the logical
directory =/media/sda1=. The "Used" column tells me how many kilobytes
are stored on this device, and another column tells me that this device
is 100% full. It is possible that you will see different results because
you have different hardware on your machine.

With =df=, the directories shown at the right are normally the ones that
we access. You can also run the command =mount=, with no arguments, to
see some of the same associations. The mount command, with arguments, is
intended for use by system administrators to configure the different
disk drives and other devices on a Unix machine. You should run the
=mount= command now, but it is not important for you to understand the
output now.

With the =du= command, you can find the "disk usage" for a directory
and all of its subdirectories, recursively. If you type =du= with no
arguments, it reports information for the current working
directory. If you provide an argument, typically a directory, it
reports information for that. Try that with a command similar to =du
/etc= or =du ~/Documents=. The results should match closely, although
maybe not precisely, the output reported by =df=.

#+BEGIN_SIDEBAR
The default units displayed by =df= and =du= are sometimes not easy to
read and understand, especially for very large amounts. Sometimes it
would be nice to print values in terms of kilobytes, megabytes, etc.

#+BEGIN_EXAMPLE
Filesystem      Size  Used Avail Use% Mounted on
rootfs           18G  8.0G  8.9G  48% /
dev             1.9G     0  1.9G   0% /dev
/dev/sda3        18G  8.0G  8.9G  48% /
tmpfs           1.9G  2.3M  1.9G   1% /tmp
/dev/sda10      207G  135G   73G  66% /Users
/dev/sda4        93M   61M   28M  69% /boot
/dev/sda5       7.5G  7.0G  492M  94% /var
/dev/sda9       111G   74G   37G  68% /home
#+END_EXAMPLE

Take a look at the =man= page for =du= and =df= to see if there's a way
to display "human readable" output.
#+END_SIDEBAR

* Timesavers

Most of today's Unix shells maintain a "history" of recent commands
that you have executed.

Type the command history to see what you have done during your shell
session. You should get a listing of commands, shown in order with a
number at the left. For example, you may see something like this:

#+BEGIN_EXAMPLE
$ history
  ...
  501  pwd
  502  df
  503  du /etc/
  504  history
$
#+END_EXAMPLE

You can re-run one of those commands by using the special character !
and referring to the number at the left. In this example, I could re-run
the du command by typing =!503= .

You can also re-run one of the commands in your history by typing =!=
followed by part of the command itself. For example, I can re-run the
most recent command that started with "=pw=" by typing =!pw=. In the
example above, the shell would convert that to =pwd= and then run that.

So this is something like using the up/down arrows to select recent
shell commands. Except that here, you can look over a longer list at
once, rather than scrolling through them one by one. And, if you
remember the command that you want to re-run, you don't have to scroll
to it; just type =!= followed by part of the command.

* Finishing up

That's the end of this execise. It is a good idea to take a break, and
then run through these new commands again.
